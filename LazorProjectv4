import datetime
import sys
import itertools
import copy


class Block:
    """
    Represents a block element in the lazor grid with a specific type.

    Attributes:
        block_type (str): The type of block, typically 'A', 'B', or 'C'.
    """

    def __init__(self, block_type):
        self.block_type = block_type


def get_block_interaction_edge_directional(edge_type, block_type, direction):
    """
    Determines the new directions for the lazor beam when it interacts with a block.

    Depending on the block type and the edge (horizontal or vertical) that the beam hits,
    the function calculates and returns the new direction(s) after reflection or propagation.

    Args:
        edge_type (str): The edge where the beam hits; either "horizontal" or "vertical".
        block_type (str): The block's type, expected to be 'A', 'B', or 'C'.
        direction (tuple): The current direction vector as (dx, dy).

    Returns:
        list: A list of one or more new direction vectors (tuples) after interaction.
    """
    dx, dy = direction
    if block_type == 'A':  # Reflective block
        if edge_type == 'horizontal':
            return [(dx, -dy)]  # Reflect vertically: flip dy
        elif edge_type == 'vertical':
            return [(-dx, dy)]  # Reflect horizontally: flip dx
    elif block_type == 'B':
        # Type B blocks do nothing (block the laser), hence no new directions.
        return []
    elif block_type == 'C':
        # For type C blocks: laser continues in the same direction and reflects
        # off the hit edge.
        if edge_type == 'horizontal':
            return [direction, (dx, -dy)]
        elif edge_type == 'vertical':
            return [direction, (-dx, dy)]
    # Default: no special interaction, continue with the same direction.
    return [direction]


def simulate_lazor_with_directional_logic(grid, lazors):
    """
    Simulates the propagation of lazor beams through the grid using directional logic.

    This function takes a grid layout and a set of initial lazor beams, then computes the
    full path of each lazor by simulating interactions with blocks, reflections, and splits.

    Args:
        grid (list of list): The grid representing the game board where each element
                             can be a Block instance or a marker ('x', 'o', etc.).
        lazors (list): A list of tuples representing the initial lazor beams.
                        Each tuple contains the starting position (x, y) and direction (dx, dy).

    Returns:
        list: A list of positions (tuples) that the lazor traversed.
    """
    active = list(
        lazors)  # List of beams to simulate, each as (position, direction)
    path = []              # Record of all positions that the beam has traveled through
    visited = set()        # Set to avoid processing the same position and direction repeatedly
    # Tracks if a beam is currently inside a block; key: (x, y) of block
    inside_blocks = {}
    height, width = len(grid), len(grid[0])

    while active:
        pos, direction = active.pop()
        key = (pos, direction)
        if key in visited:
            continue
        visited.add(key)

        # Propagate beam until it leaves the grid bounds.
        while 0 <= pos[0] < width * 2 and 0 <= pos[1] < height * 2:
            path.append(pos)
            next_pos = (pos[0] + direction[0], pos[1] + direction[1])

            # Check interaction with each block in the grid.
            for y in range(height):
                for x in range(width):
                    block = grid[y][x]
                    if isinstance(block, Block):
                        # Get the edge positions for the current block.
                        edges = get_block_edges(x, y)
                        for side, coord in edges.items():
                            if coord == pos:
                                # Check if the block is hit. For non-type 'C',
                                # avoid re-hitting the same block.
                                if block.block_type != 'C' and (
                                        x, y) in inside_blocks:
                                    continue
                                if block.block_type == 'C' and (
                                        x, y) in inside_blocks:
                                    continue
                                # Determine the edge type based on which side
                                # was hit.
                                edge_type = 'horizontal' if side in [
                                    'top', 'bottom'] else 'vertical'
                                print(
                                    f"Edge hit: {coord} ({side}) of block ({x}, {y}) type {block.block_type} from {pos} to {next_pos}")
                                # Calculate new directions based on the type
                                # and edge hit.
                                new_dirs = get_block_interaction_edge_directional(
                                    edge_type, block.block_type, direction)
                                # Reset next_pos for the primary beam.
                                next_pos = (
                                    pos[0] + direction[0], pos[1] + direction[1])
                                # For additional new directions (if any), queue
                                # them for later simulation.
                                for new_direction in new_dirs[1:]:
                                    alt_next = (
                                        pos[0] + new_direction[0], pos[1] + new_direction[1])
                                    active.append((alt_next, new_direction))
                                if new_dirs:
                                    # Mark block as being "entered" to avoid
                                    # duplicate hits in future.
                                    if block.block_type == 'C':
                                        inside_blocks[(x, y)] = True
                                    else:
                                        inside_blocks[(x, y)] = None
                                    # Continue the beam in the primary new
                                    # direction.
                                    direction = new_dirs[0]
                                else:
                                    # Terminate the beam if no direction is
                                    # available.
                                    next_pos = None
                                break
                        else:
                            # If inner loop was not broken (i.e., no hit on
                            # current block edge), continue checking.
                            continue
                        break  # Break out after processing a hit on a block.
            if next_pos is None:
                break
            # Update position for the next iteration.
            next_pos = (pos[0] + direction[0], pos[1] + direction[1])
            pos = next_pos
            visited.add((pos, direction))

    return path


def get_block_edges(x, y):
    """
    Returns the coordinate positions of the edges for a block at grid cell (x, y).

    The grid assumes each block is centered, and the edge positions are computed based on the
    center coordinate. Each block's center is calculated as (x * 2 + 1, y * 2 + 1).

    Args:
        x (int): The x-coordinate (column index) of the block in the grid.
        y (int): The y-coordinate (row index) of the block in the grid.

    Returns:
        dict: A dictionary mapping each side ('top', 'bottom', 'left', 'right') to its coordinate.
    """
    center_x, center_y = x * 2 + 1, y * 2 + 1
    return {
        'top': (center_x, center_y - 1),
        'bottom': (center_x, center_y + 1),
        'left': (center_x - 1, center_y),
        'right': (center_x + 1, center_y)
    }


# --- Permutation Solver ---

def parse_bff(filename):
    """
    Parses a BFF file containing the puzzle configuration.

    The BFF file contains details on the grid layout, counts of each block type,
    initial lazor positions and directions, as well as the target points.
    Lines starting with '#' are comments and are ignored.

    Args:
        filename (str): The path to the BFF configuration file.

    Returns:
        tuple: A tuple containing the following elements:
            - grid (list of list): The puzzle grid with blocks and markers.
            - blocks (dict): A mapping of block types ('A', 'B', 'C') to their counts.
            - lazors (list): A list of lazor beams defined by their start position and direction.
            - points (list): A list of target point coordinates that must be hit.
    """
    with open(filename, 'r') as f:
        # Remove empty lines and comments.
        lines = [line.strip() for line in f if line.strip()
                 and not line.startswith('#')]

    grid = []
    blocks = {'A': 0, 'B': 0, 'C': 0}
    lazors = []
    points = []

    i = 0
    while i < len(lines):
        if lines[i] == "GRID START":
            i += 1
            # Read grid rows until "GRID STOP" is encountered.
            while lines[i] != "GRID STOP":
                row = lines[i].split()
                grid.append([
                    None if ch == 'x'
                    else Block(ch) if ch in ['A', 'B', 'C']
                    else ch for ch in row
                ])
                i += 1
        elif lines[i][0] in ['A', 'B', 'C'] and lines[i][1] == ' ':
            # Read the available count for a block type.
            typ, count = lines[i].split()
            blocks[typ] = int(count)
        elif lines[i].startswith('L'):
            # Read a lazor line with start position and direction.
            _, x, y, dx, dy = lines[i].split()
            lazors.append(((int(x), int(y)), (int(dx), int(dy))))
        elif lines[i].startswith('P'):
            # Read a target point position.
            _, x, y = lines[i].split()
            points.append((int(x), int(y)))
        i += 1

    return grid, blocks, lazors, points


def place_blocks(grid, block_positions, block_types):
    """
    Places blocks into a copy of the grid based on the specified positions and types.

    Args:
        grid (list of list): The base grid representing the puzzle board.
        block_positions (list): A list of (x, y) tuples where blocks can be placed.
        block_types (list): A list of block types corresponding to each position.

    Returns:
        list of list: A new grid with the blocks placed accordingly.
    """
    new_grid = copy.deepcopy(grid)
    for (x, y), block_type in zip(block_positions, block_types):
        new_grid[y][x] = Block(block_type)
    return new_grid


def find_open_positions(grid):
    """
    Identifies and returns all open positions (where a block can be placed) in the grid.

    In the grid, an open position is marked with the character 'o'.

    Args:
        grid (list of list): The puzzle grid.

    Returns:
        list: A list of (x, y) tuples representing open positions.
    """
    return [(x, y) for y in range(len(grid))
            for x in range(len(grid[0])) if grid[y][x] == 'o']


def check_targets_hit(path, targets):
    """
    Checks whether all target points have been hit by the lazor beam.

    Args:
        path (list): A list of positions (tuples) that the lazor beam has traversed.
        targets (list): A list of target point positions (tuples) that need to be hit.

    Returns:
        bool: True if every target point is in the path, False otherwise.
    """
    return all(p in path for p in targets)


def solve_with_permutations(grid, blocks, lazors, targets):
    """
    Attempts to solve the lazor puzzle using permutations of block placements.

    The solver finds all open positions from the grid and tests different block placement
    combinations and block type assignments to determine a configuration where all target
    points are hit by the lazor beam path.

    Args:
        grid (list of list): The base grid (with pre-defined obstacles/open spaces).
        blocks (dict): Dictionary with counts of available block types.
        lazors (list): List of lazor beams (start positions and directions).
        targets (list): List of target point coordinates.

    Returns:
        tuple: (solution_grid, solution_path) where solution_grid is the grid with blocks placed
               that results in a solution, and solution_path is the lazor path.
               If no solution is found, returns (None, None).
    """
    open_positions = find_open_positions(grid)
    # Create a list of blocks available for placement; note: only blocks 'A'
    # and 'C' are used.
    block_list = ['A'] * blocks['A'] + ['C'] * blocks['C']

    tried_configs = set()

    # Try every combination of positions for the available blocks.
    for positions in itertools.combinations(open_positions, len(block_list)):
        # Try every permutation of block types for those positions.
        for types in set(itertools.permutations(block_list)):
            key = tuple(sorted(zip(positions, types)))
            if key in tried_configs:
                continue
            tried_configs.add(key)

            test_grid = place_blocks(grid, positions, types)
            path = simulate_lazor_with_directional_logic(test_grid, lazors)
            # Check if this configuration successfully hits all target points.
            if check_targets_hit(path, targets):
                return test_grid, path

    return None, None


# --- Main Execution ---

# Redirect standard output to a log file for record keeping.
log_filename = f"lazor_log_{datetime.datetime.now().strftime('%Y%m%d_%H%M%S')}.txt"
sys.stdout = open(log_filename, "w")
print("Log started for Lazor solver")

if __name__ == "__main__":
    # Parse the BFF configuration file to extract grid, block counts, lazors,
    # and target points.
    bff_file = "mad_4.bff"
    grid, block_counts, lazors, targets = parse_bff(bff_file)

    # Attempt to solve the puzzle with the given configuration.
    solution_grid, solution_path = solve_with_permutations(
        grid, block_counts, lazors, targets)

    # Print and log the result.
    if solution_grid:
        print("\nSolution found! Lazor path:")
        for p in solution_path:
            print(p)

        # Write the solution grid and lazor path to an output file.
        with open("solution_output.txt", "w") as f:
            f.write("Solution Grid (block layout):\n")
            for row in solution_grid:
                # Convert each cell to a character representation for the
                # output.
                line = ' '.join(
                    cell.block_type if isinstance(
                        cell, Block) else (
                        'o' if cell == 'o' else 'x') for cell in row)
                f.write(line + "\n")

            f.write("\nLazor Path:\n")
            for p in solution_path:
                f.write(f"{p}\n")

            f.write("\nTarget Points Hit:\n")
            for t in targets:
                status = 'HIT' if t in solution_path else 'MISS'
                f.write(f"{t} - {status}\n")

        print("\nSolution written to solution_output.txt")
    else:
        print("\nNo solution found.")
